## 测试nodejs redis发布订阅模式性能及优化

____
[ws issues]https://github.com/websockets/ws/issues/804
____


+ ws服务器最大连接数控制5000，每隔30秒手动gc一次
+ redis publish端大于14/s速度生产数据
+ redis subscribe端不控制并发广播publish数据
+ 所有客户端模拟接收数据

### 测试1

+ 服务器单独模拟大于14次/s广播推送消息，cpu基本跑满，mem占用在200M浮动
+ 客户端断开连接后，服务器回到正常，gc没有问题

### 测试2

+ 服务器单独监听publish，不处理接收到的消息
+ publish端大于14条/s速度发送事件
+ 服务器cpu为0，mem在60M上下浮动

### 测试3

+ 服务器监听publish消息，并将收到的消息广播给连接的客户端
+ 服务器cpu100%，mem无限增长，客户端连接变慢，gc基本停顿状态（偶尔可以gc，但内存很快又满了，超过1g）
+ 不管是断开客户端还是断开publish端，服务器处于假死状态（已停止对外服务）
+ 如果单独断开publish端，服务器继续消费积压的消息，消费完所有消息后可以回到正常状态

### 结论

+ 单独的生产消息与单独的推送消息nodejs服务器在5000个连接的情况下是可以正常运行的（gc正常）
+ 如果生产者速度>消费者速度造成消息在消费者端积压，会导致消费者内存暴涨，持续一段时间后，gc崩溃，整个服务crash
+ nodejs redis客户端发布订阅会使用队列来积压数据，这是内存爆涨的原因
+ 内存/cpu过高会影响nodejs gc，导致事件循环处理事件能力下降并阻塞，事件阻塞又会导致其它事件得不到执行（比如gc）

### 解决方案

1. 降低生产者生产速度（减小subscribe触发次数）
+ 让生产者分类处理消息，去掉相关不必要的广播
+ 生产者可以合并一些可以同时发送的消息，一次性广播出去

2. 限制消息者消费速度（通过其它方式来缓存消息，不去占用nodejs堆栈）
+ 使用buffer来缓存消息（nodejs的堆外内存）
+ 根据cpu使用率情况，限制消费者拿取缓存并推送消息的频率

3. 限制客户端连接服务器数量

4. 压测生产速度与消费速度，并尽可能保持平衡，可以有一定积压
